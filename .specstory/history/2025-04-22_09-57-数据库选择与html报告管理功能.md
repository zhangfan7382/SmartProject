<!-- Generated by SpecStory -->

# 数据库选择与HTML报告管理功能 (2025-04-22 17:57:20)

_**User**_

这个项目推荐使用什么数据库，想要加入一个生成html，并且上传下载的功能

---

_**Assistant**_

对于这个自动化测试平台，我建议使用以下技术栈：

1. 数据库选择：
- PostgreSQL：适合存储测试用例、测试报告等结构化数据
- MongoDB：如果测试数据格式比较灵活，也可以考虑使用

2. 文件存储：
- 对于HTML报告文件，建议使用对象存储服务：
  - 阿里云OSS
  - 腾讯云COS
  - 或者自建MinIO

以下是实现HTML报告上传下载功能的代码示例：

```vue:src/App.vue
// ... existing code ...

<script setup lang="ts">
import { ref } from 'vue'
import axios from 'axios'

const fileList = ref([])
const uploading = ref(false)

// 上传HTML报告
const handleUpload = async (file) => {
  const formData = new FormData()
  formData.append('file', file)
  
  try {
    uploading.value = true
    const response = await axios.post('/api/reports/upload', formData, {
      headers: {
        'Content-Type': 'multipart/form-data'
      }
    })
    fileList.value.push(response.data)
  } catch (error) {
    console.error('上传失败:', error)
  } finally {
    uploading.value = false
  }
}

// 下载HTML报告
const handleDownload = async (reportId) => {
  try {
    const response = await axios.get(`/api/reports/download/${reportId}`, {
      responseType: 'blob'
    })
    const url = window.URL.createObjectURL(new Blob([response.data]))
    const link = document.createElement('a')
    link.href = url
    link.setAttribute('download', `report_${reportId}.html`)
    document.body.appendChild(link)
    link.click()
    document.body.removeChild(link)
  } catch (error) {
    console.error('下载失败:', error)
  }
}
</script>

<template>
  // ... existing code ...
  
  <div class="reports-section">
    <h2>测试报告管理</h2>
    <div class="upload-section">
      <input 
        type="file" 
        accept=".html"
        @change="(e) => handleUpload(e.target.files[0])"
        :disabled="uploading"
      >
      <span v-if="uploading">上传中...</span>
    </div>
    
    <div class="reports-list">
      <div v-for="report in fileList" :key="report.id" class="report-item">
        <span>{{ report.name }}</span>
        <button @click="handleDownload(report.id)">下载</button>
      </div>
    </div>
  </div>
</template>

<style>
// ... existing code ...

.reports-section {
  padding: 20px;
  background: white;
  border-radius: 8px;
  margin-top: 20px;
}

.upload-section {
  margin-bottom: 20px;
}

.reports-list {
  display: grid;
  gap: 10px;
}

.report-item {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 10px;
  background: #f5f5f5;
  border-radius: 4px;
}

.report-item button {
  padding: 5px 10px;
  background: var(--primary-color);
  color: white;
  border: none;
  border-radius: 4px;
  cursor: pointer;
}

.report-item button:hover {
  opacity: 0.9;
}
</style>
```

后端API示例（Node.js + Express）：

```javascript:src/server/routes/reports.js
const express = require('express');
const router = express.Router();
const multer = require('multer');
const path = require('path');

// 配置multer存储
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    cb(null, 'uploads/reports');
  },
  filename: (req, file, cb) => {
    cb(null, `${Date.now()}-${file.originalname}`);
  }
});

const upload = multer({ storage });

// 上传报告
router.post('/upload', upload.single('file'), async (req, res) => {
  try {
    const report = {
      id: Date.now(),
      name: req.file.originalname,
      path: req.file.path,
      createdAt: new Date()
    };
    
    // 保存到数据库
    await db.collection('reports').insertOne(report);
    
    res.json(report);
  } catch (error) {
    res.status(500).json({ error: '上传失败' });
  }
});

// 下载报告
router.get('/download/:id', async (req, res) => {
  try {
    const report = await db.collection('reports').findOne({ id: parseInt(req.params.id) });
    if (!report) {
      return res.status(404).json({ error: '报告不存在' });
    }
    
    res.download(report.path);
  } catch (error) {
    res.status(500).json({ error: '下载失败' });
  }
});

module.exports = router;
```

这个实现提供了以下功能：
1. 上传HTML报告文件
2. 显示报告列表
3. 下载报告文件
4. 响应式设计，适配移动端

建议：
1. 添加文件大小限制
2. 添加文件类型验证
3. 添加进度条显示
4. 添加文件预览功能
5. 添加文件删除功能
6. 添加文件分类管理
7. 添加搜索和筛选功能

需要根据具体需求进行调整和扩展。

---

_**User**_

不推荐 sqlite 或者 mysql吗

---

_**Assistant**_

对于这个自动化测试平台，我建议使用以下数据库方案：

1. 主要数据库选择：
- PostgreSQL：更适合这个场景，因为：
  - 支持JSON类型，可以灵活存储测试用例和报告数据
  - 性能优秀，支持复杂查询
  - 支持全文搜索
  - 有完善的事务支持
  - 适合处理大量数据

2. 为什么不推荐SQLite：
- 虽然SQLite简单易用，但：
  - 并发性能较差
  - 不适合多用户同时访问
  - 文件锁可能导致性能问题
  - 不适合生产环境的高并发场景

3. 为什么不推荐MySQL：
- MySQL虽然广泛使用，但：
  - JSON支持不如PostgreSQL完善
  - 全文搜索功能较弱
  - 对于复杂查询性能不如PostgreSQL
  - 在数据一致性方面不如PostgreSQL严格

以下是使用PostgreSQL的示例代码：

```typescript:src/db/config.ts
import { Pool } from 'pg'

const pool = new Pool({
  user: process.env.DB_USER,
  host: process.env.DB_HOST,
  database: process.env.DB_NAME,
  password: process.env.DB_PASSWORD,
  port: parseInt(process.env.DB_PORT || '5432'),
  max: 20, // 连接池最大连接数
  idleTimeoutMillis: 30000,
  connectionTimeoutMillis: 2000,
})

export default pool
```

```typescript:src/db/models/report.ts
import pool from '../config'

export interface Report {
  id: number
  name: string
  content: string
  created_at: Date
  metadata: {
    test_count: number
    passed_count: number
    failed_count: number
    duration: number
  }
}

export const createReport = async (report: Omit<Report, 'id' | 'created_at'>) => {
  const query = `
    INSERT INTO reports (name, content, metadata)
    VALUES ($1, $2, $3)
    RETURNING id, created_at
  `
  const values = [report.name, report.content, report.metadata]
  const result = await pool.query(query, values)
  return result.rows[0]
}

export const getReport = async (id: number): Promise<Report> => {
  const query = `
    SELECT * FROM reports
    WHERE id = $1
  `
  const result = await pool.query(query, [id])
  return result.rows[0]
}

export const getReports = async (page = 1, limit = 10): Promise<Report[]> => {
  const offset = (page - 1) * limit
  const query = `
    SELECT * FROM reports
    ORDER BY created_at DESC
    LIMIT $1 OFFSET $2
  `
  const result = await pool.query(query, [limit, offset])
  return result.rows
}
```

```sql:src/db/migrations/001_create_reports_table.sql
CREATE TABLE reports (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  content TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
  metadata JSONB NOT NULL
);

CREATE INDEX idx_reports_created_at ON reports(created_at);
CREATE INDEX idx_reports_metadata ON reports USING GIN (metadata);
```

PostgreSQL的优势：
1. 支持JSONB类型，可以灵活存储测试报告数据
2. 支持全文搜索，方便搜索报告内容
3. 支持复杂查询，可以方便地统计和分析测试数据
4. 支持事务，保证数据一致性
5. 支持并发，适合多用户同时访问
6. 支持索引，提高查询性能
7. 支持分区表，可以处理大量数据

建议：
1. 使用连接池管理数据库连接
2. 使用ORM框架（如TypeORM）简化数据库操作
3. 使用迁移工具（如Knex）管理数据库结构
4. 使用缓存（如Redis）提高性能
5. 定期备份数据
6. 监控数据库性能

---



---

